diff --git a/src/sha256/table16/compression/subregion_digest.rs b/src/sha256/table16/compression/subregion_digest.rs
index 28df0ba..a2dd9d1 100644
--- a/src/sha256/table16/compression/subregion_digest.rs
+++ b/src/sha256/table16/compression/subregion_digest.rs
@@ -1,18 +1,18 @@
-use super::super::{super::DIGEST_SIZE, BlockWord, RoundWordDense};
+use super::super::{super::DIGEST_SIZE, AssignedWord32, RoundWordDense};
 use super::{compression_util::*, CompressionConfig, State};
 use halo2_proofs::{
-    circuit::{Region, Value},
+    circuit::Region,
     pasta::pallas,
     plonk::{Advice, Column, Error},
 };
 
 impl CompressionConfig {
     #[allow(clippy::many_single_char_names)]
-    pub fn assign_digest(
+    pub fn assign_digest_cells(
         &self,
         region: &mut Region<'_, pallas::Base>,
         state: State,
-    ) -> Result<[BlockWord; DIGEST_SIZE], Error> {
+    ) -> Result<[AssignedWord32; DIGEST_SIZE], Error> {
         let a_3 = self.extras[0];
         let a_4 = self.extras[1];
         let a_5 = self.message_schedule;
@@ -34,13 +34,17 @@ impl CompressionConfig {
         a.dense_halves
             .1
             .copy_advice(|| "a_hi", region, a_4, abcd_row)?;
-        let a = a.dense_halves.value();
-        region.assign_advice(
+        let a_value = a.dense_halves.value();
+        let a_cell = region.assign_advice(
             || "a",
             a_5,
             abcd_row,
-            || a.map(|a| pallas::Base::from(a as u64)),
+            || a_value.map(|a| pallas::Base::from(a as u64)),
         )?;
+        let a = AssignedWord32 {
+            cell: a_cell,
+            value: a_value,
+        };
 
         let b = self.assign_digest_word(region, abcd_row, a_6, a_7, a_8, b.dense_halves)?;
         let c = self.assign_digest_word(region, abcd_row + 1, a_3, a_4, a_5, c.dense_halves)?;
@@ -53,27 +57,24 @@ impl CompressionConfig {
         e.dense_halves
             .1
             .copy_advice(|| "e_hi", region, a_4, efgh_row)?;
-        let e = e.dense_halves.value();
-        region.assign_advice(
+        let e_value = e.dense_halves.value();
+        let e_cell = region.assign_advice(
             || "e",
             a_5,
             efgh_row,
-            || e.map(|e| pallas::Base::from(e as u64)),
+            || e_value.map(|e| pallas::Base::from(e as u64)),
         )?;
+        let e = AssignedWord32 {
+            cell: e_cell,
+            value: e_value,
+        };
 
         let f = self.assign_digest_word(region, efgh_row, a_6, a_7, a_8, f.dense_halves)?;
         let g = self.assign_digest_word(region, efgh_row + 1, a_3, a_4, a_5, g.dense_halves)?;
         let h = self.assign_digest_word(region, efgh_row + 1, a_6, a_7, a_8, h)?;
 
         Ok([
-            BlockWord(a),
-            BlockWord(b),
-            BlockWord(c),
-            BlockWord(d),
-            BlockWord(e),
-            BlockWord(f),
-            BlockWord(g),
-            BlockWord(h),
+            a, b, c, d, e, f, g, h,
         ])
     }
 
@@ -85,18 +86,18 @@ impl CompressionConfig {
         hi_col: Column<Advice>,
         word_col: Column<Advice>,
         dense_halves: RoundWordDense,
-    ) -> Result<Value<u32>, Error> {
+    ) -> Result<AssignedWord32, Error> {
         dense_halves.0.copy_advice(|| "lo", region, lo_col, row)?;
         dense_halves.1.copy_advice(|| "hi", region, hi_col, row)?;
 
-        let val = dense_halves.value();
-        region.assign_advice(
+        let value = dense_halves.value();
+        let cell = region.assign_advice(
             || "word",
             word_col,
             row,
-            || val.map(|val| pallas::Base::from(val as u64)),
+            || value.map(|val| pallas::Base::from(val as u64)),
         )?;
 
-        Ok(val)
+        Ok(AssignedWord32 { cell, value })
     }
 }
diff --git a/src/sha256/table16/compression.rs b/src/sha256/table16/compression.rs
index 528b1d9..dd40fe4 100644
--- a/src/sha256/table16/compression.rs
+++ b/src/sha256/table16/compression.rs
@@ -1,7 +1,8 @@
 use super::{
     super::DIGEST_SIZE,
     util::{i2lebsp, lebs2ip},
-    AssignedBits, BlockWord, SpreadInputs, SpreadVar, Table16Assignment, ROUNDS, STATE,
+    AssignedBits, AssignedWord32, BlockWord, SpreadInputs, SpreadVar, Table16Assignment, ROUNDS,
+    STATE,
 };
 use halo2_proofs::{
     circuit::{Layouter, Value},
@@ -922,16 +923,23 @@ impl CompressionConfig {
         layouter: &mut impl Layouter<pallas::Base>,
         state: State,
     ) -> Result<[BlockWord; DIGEST_SIZE], Error> {
-        let mut digest = [BlockWord(Value::known(0)); DIGEST_SIZE];
-        layouter.assign_region(
+        let digest_cells = layouter.assign_region(
             || "digest",
-            |mut region| {
-                digest = self.assign_digest(&mut region, state.clone())?;
-
-                Ok(())
-            },
+            |mut region| self.assign_digest_cells(&mut region, state.clone()),
         )?;
-        Ok(digest)
+        Ok(digest_cells.map(|word| BlockWord(word.value)))
+    }
+
+    /// After the final round, return the per-word digest deltas with assigned cells.
+    pub(super) fn digest_cells(
+        &self,
+        layouter: &mut impl Layouter<pallas::Base>,
+        state: State,
+    ) -> Result<[AssignedWord32; DIGEST_SIZE], Error> {
+        layouter.assign_region(
+            || "digest",
+            |mut region| self.assign_digest_cells(&mut region, state.clone()),
+        )
     }
 }
 
diff --git a/src/sha256/table16.rs b/src/sha256/table16.rs
index 9e56c78..e5c2fae 100644
--- a/src/sha256/table16.rs
+++ b/src/sha256/table16.rs
@@ -35,7 +35,8 @@ pub(crate) const ROUND_CONSTANTS: [u32; ROUNDS] = [
     0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,
 ];
 
-const IV: [u32; STATE] = [
+/// SHA-256 initial hash state words (the standard IV).
+pub const IV: [u32; STATE] = [
     0x6a09_e667,
     0xbb67_ae85,
     0x3c6e_f372,
@@ -51,6 +52,15 @@ const IV: [u32; STATE] = [
 // TODO: Make the internals of this struct private.
 pub struct BlockWord(pub Value<u32>);
 
+/// A 32-bit word represented in-circuit as `pallas::Base::from(word)`.
+#[derive(Clone, Debug)]
+pub struct AssignedWord32 {
+    /// The assigned cell holding `pallas::Base::from(word)`.
+    pub cell: AssignedCell<pallas::Base, pallas::Base>,
+    /// The native `u32` witness value used for host-side arithmetic.
+    pub value: Value<u32>,
+}
+
 #[derive(Clone, Debug)]
 /// Little-endian bits (up to 64 bits)
 pub struct Bits<const LEN: usize>([bool; LEN]);
@@ -324,6 +334,15 @@ impl Table16Chip {
     ) -> Result<(), Error> {
         SpreadTableChip::load(config.lookup, layouter)
     }
+
+    /// Converts the internal state into post-round words while preserving assigned cells.
+    pub fn digest_cells(
+        &self,
+        layouter: &mut impl Layouter<pallas::Base>,
+        state: &State,
+    ) -> Result<[AssignedWord32; super::DIGEST_SIZE], Error> {
+        self.config().compression.digest_cells(layouter, state.clone())
+    }
 }
 
 impl Sha256Instructions<pallas::Base> for Table16Chip {
diff --git a/src/sha256.rs b/src/sha256.rs
index 3e4cdaf..d51d29f 100644
--- a/src/sha256.rs
+++ b/src/sha256.rs
@@ -14,12 +14,12 @@ use halo2_proofs::{
 
 mod table16;
 
-pub use table16::{BlockWord, Table16Chip, Table16Config};
+pub use table16::{AssignedWord32, BlockWord, Table16Chip, Table16Config, IV};
 
 /// The size of a SHA-256 block, in 32-bit words.
 pub const BLOCK_SIZE: usize = 16;
 /// The size of a SHA-256 digest, in 32-bit words.
-const DIGEST_SIZE: usize = 8;
+pub const DIGEST_SIZE: usize = 8;
 
 /// The set of circuit instructions required to use the [`Sha256`] gadget.
 pub trait Sha256Instructions<F: Field>: Chip<F> {
